#!/bin/bash -e
# Copyright (c) 2011-2021 TurnKey GNU/Linux - http://www.turnkeylinux.org
# 
# This file is part of buildtasks.
# 
# Buildtasks is free software; you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.


fatal() { echo "FATAL [$(basename $0)]: $@" 1>&2; exit 1; }
warning() { echo "WARNING [$(basename $0)]: $@"; }
info() { echo "INFO [$(basename $0)]: $@"; }

usage() {
    cat<<EOF
Syntax: $(basename $0) [--publish | -u] [-n] [-s] appname
Builds appliance appname (e.g., core) ISO

Arguments::

    appname             - e.g., core

Options::

    -n|--no-screens     - skip taking screenshots
    -u|--use-existing   - use an existing iso, rather than rebuilding, will
                          fail if iso does not exist
    -s|--skip-setup     - skip the inital setup step
    --publish           - publish iso, release files and tklbam profile,
                          incompatible with -u|--use-existing and
                          -s|--skip-setup

Environment::

    WEBDRIVER_CONNECT_ATTEMPTS
                        - number of times to (re)try connection to webdriver
                          container (for screenshots)
                          DEFAULT: $WEBDRIVER_CONNECT_ATTEMPTS
    WEBDRIVER_CONNECT_TIMEOUT
                        - time (in seconds) to wait between webdriver
                          connection attempts (for screenshots)
                          DEFAULT: $WEBDRIVER_CONNECT_TIMEOUT
    BT_DEBUG            - turn on debugging

EOF
    if [[ "$#" -ne 0 ]]; then
        echo "Error: $@"
        exit 1
    fi
    exit
}

clone_or_pull() {
    # If $dir doesn't exist, clone $repo. If it does, update from origin master
    dir=$1
    repo=$2
    [[ -n "$dir" ]] && [[ -n "$repo" ]] \
        || fatal "One or more empty values passed to function: $FUNCNAME."
    if [ ! -e $dir ]; then
        info "Attempting to clone repo $repo to $dir."
        cd $(dirname $dir)
        git clone https://github.com/$repo $dir
        cd $dir
    else
        info "Repo $repo found, attempting to update"
        cd $dir
        git pull origin master
    fi
}

get_version() {
    pkg=$1
    sp="[[:space:]]"
    pkg_info=$(dpkg -l \
        | sed -En "s|^ii.*($pkg)$sp*([0-9a-z\.-:]*)$sp*amd64$sp*.*|\1 \2|p")
    echo $pkg_info | cut -d' ' -f2
}

git_unshallow() {
    local dir=$1
    local branch=$2
    # assume TKL remote is 'origin'
    local remote=origin
    cd $dir
    if [[ "$(git symbolic-ref --short HEAD)" != "$branch" ]]; then
        git remote set-branches origin '*'
        git fetch origin --unshallow 2>/dev/null || git fetch origin
        git checkout $branch || git checkout $branch-dev
    fi
    cd -
}

get_codename() {
    local tkl_ver=$1
    case $tkl_ver in
        16*)
            TKL_CODENAME=buster;;
        17*)
            TKL_CODENAME=bullseye;;
        18*)
            TKL_CODENAME=bookworm;;
        19*)
            TKL_CODENAME=trixie;;
        *)
            fatal "Unrecognised TKL version: $tkl_ver";;
    esac
}

container_status() {
    podman container inspect $1 --format "{{.State.Status}}"
}

export WEBDRIVER_CONNECT_ATTEMPTS=${WEBDRIVER_CONNECT_ATTEMPTS:-200}
export WEBDRIVER_CONNECT_TIMEOUT=${WEBDRIVER_CONNECT_TIMEOUT:-5}
ARGS="$@"
unset no_screens use_existing appname skip_setup TKL_CODENAME
while [[ "$1" != "" ]]; do
    case $1 in
        --help|-h)          usage;;
        --publish)          publish="yes";;
        -n|--no-screens)    no_screens="true";;
        -s|--skip-setup)    skip_setup="true";;
        -u|--use-existing)  use_existing="true";;
        *)                  if [[ -n "$appname" ]]; then
                                usage "Accepts only one appliance name"
                            else
                                appname=$1
                            fi;;
    esac
    shift
done

[[ -n "$appname" ]] || usage "Must give one app name"
[[ -z "$BT_DEBUG" ]] || set -x

# adjust which clicksnap module to use where need be
if [[ -z "$no_screens" ]]; then
    case $appname in
        tkldev)
            info "TKLDev build - disabling screenshots as no web UI"
            no_screens="true";;
        *)
            clicksnap_mod=$(sed "s|-|_|g" <<<$appname);;
    esac
fi

export BT=$(dirname $(readlink -f $0))
export BT_CONFIG=$BT/config
. $BT_CONFIG/common.cfg

if [[ "$publish" == "yes" ]]; then
    unset msg
    [[ -n "$BT_PUBLISH_IMGS" ]] || fatal "BT_PUBLISH_IMGS not set"
    [[ -n "$BT_PUBLISH_META" ]] || fatal "BT_PUBLISH_META not set"
    [[ -n "$BT_PUBLISH_SCREENS" ]] || fatal "BT_PUBLISH_SCREENS not set"
    [[ -n "$BT_PUBLISH_PROFILES" ]] || fatal "BT_PUBLISH_PROFILES not set"
    [[ -z "$use_existing" ]] || usage "conflicting options: --publish / -u|--use-existing"
    [[ -z "$skip_setup" ]] || usage "conflicting options: --publish / -s|--skip-setup"
    which aws >/dev/null || $BT/bin/aws-setup --awscli
else
    warning "--publish was not specified"
fi

cd $BT
BASE_DIR=/turnkey/public
COMMIT_ID=$(git rev-parse --short HEAD)
if [[ -z "$skip_setup" ]]; then
    # Leverage tkldev-setup to ensure important repos are cloned and at latest
    # commit; also ensures RELEASE & ARCH are set.
    tkldev-setup $appname \
        || warning "tkldev-setup failed. Attempting to continue anyway."

    # unless -n|--no-screens set up clicksnap and check for clicksnap file
    if [[ -z "$no_screens" ]]; then
        if [[ ! -f /root/clicksnap-setup.done ]]; then
            info "Setting up clicksnap and dockerize"
            $BT/bin/clicksnap-setup $appname
            touch /root/clicksnap-setup.done
        else
            setup_time=$(date -r /root/clicksnap-setup.done +%s)
            allowed_age=$(( $setup_time + 86400 )) # 24 hours
            if [[ $allowed_age -lt $(date +%s) ]]; then
                info "Attempting clicksnap update"
                clone_or_pull $BASE_DIR/clicksnap turnkeylinux/clicksnap
                touch /root/clicksnap-setup.done
            fi
            if ! ls $BASE_DIR/clicksnap/src/apps/ \
                    | grep -q -w "$clicksnap_mod"; then
                # double check that it doesn't reuse another module
                if ! grep -q "^    h.insert(\"$clicksnap_mod\", Box::new(" \
                        $BASE_DIR/clicksnap/src/apps/mod.rs; then

                    fatal "Clicksnap code for $clicksnap_mod not found" \
                          " (checked in $BASE_DIR/clicksnap/src/apps/)"
                fi
            fi
        fi
    fi

    # if TKL version doesn't match host, check out the relevant branches and
    # attempt to download the right bootstrap; otherwise build it
    TKL_HOST_VER=$(turnkey-version -t | cut -d. -f1)
    TKL_BUILD_VER=$(sed -nE "1s|turnkey-[a-z0-9-]*-([0-9]+).*|\1|p" \
        $BT_PRODUCTS/$appname/changelog)
    if [[ "$TKL_HOST_VER" != "$TKL_BUILD_VER" ]]; then
        warning "Host TKL version ($TKL_HOST_VER) does not match guest version" \
                " ($TKL_BUILD_VER)"
        unset TKL_CODENAME
        get_codename $TKL_BUILD_VER
        export RELEASE=debian/$TKL_CODENAME
        git_unshallow "/turnkey/buildtasks" "$TKL_BUILD_VER.x"
        # if buildtasks has changed, restart bt-iso
        cd $BT
        if [[ "$(git rev-parse --short HEAD)" != "$COMMIT_ID" ]]; then
            exec ./$(basename $0) $ARGS
            exit
        fi
        cd -
        git_unshallow "$FAB_PATH/common" "$TKL_BUILD_VER.x"
        KEY=$FAB_PATH/common/keys/tkl-$TKL_CODENAME-images.asc
        IMAGES="http://mirror.turnkeylinux.org/turnkeylinux/images"
        BOOTSTRAP_NAME="bootstrap-$TKL_CODENAME-$(dpkg --print-architecture)"
        BOOTSTRAP_PATH="$FAB_PATH/bootstraps/$TKL_CODENAME"

        if [[ ! -d "$BOOTSTRAP_PATH" ]]; then
            info "Attempting to download $BOOTSTRAP_NAME"
            mkdir -p $(dirname $BOOTSTRAP_PATH)
            cd $(dirname $BOOTSTRAP_PATH)
            exit_code=0
            wget -nc $IMAGES/bootstrap/$BOOTSTRAP_NAME.tar.gz || exit_code=$?
            wget -nc $IMAGES/bootstrap/$BOOTSTRAP_NAME.tar.gz.hash || exit_code=$?
            if [[ "$exit_code" -eq 0 ]]; then
                info "verifying $BOOTSTRAP_NAME"
                TMP_KEYRING="$(mktemp -d)/tmp.gpg"
                GPG="gpg --no-default-keyring --keyring $TMP_KEYRING"
                $GPG --import $FAB_PATH/common/keys/tkl-$TKL_CODENAME-images.asc
                $GPG --verify $BOOTSTRAP_NAME.tar.gz.hash

                info "unpacking $BOOTSTRAP_NAME"
                mkdir $BOOTSTRAP_PATH
                tar -zxf $BOOTSTRAP_NAME.tar.gz -C $BOOTSTRAP_PATH
                cd -
            else
                warning "Downloading bootstrap failed."
                info "Attempting to build bootstrap."
                unset PUBLISH
                BOOTSTRAP_SRC=$(dirname $FAB_PATH)/bootstrap
                [[ "$publish" != "yes" ]] || PUBLISH="--publish"
                $BT/bt-bootstrap $PUBLISH --no-clean --force \
                    || fatal "Building bootstrap failed... :("
                rsync --delete -Hac $BOOTSTRAP_SRC/build/bootstrap/ \
                    $FAB_PATH/bootstraps/$TKL_CODENAME/
                # create symlinks so bin/generate-buildenv completes successfully
                ln -s $BT_BUILDS/bootstrap/$BOOTSTRAP_NAME.tar.gz \
                    $(dirname $BOOTSTRAP_PATH)/$BOOTSTRAP_NAME.tar.gz
                ln -s $BT_BUILDS/bootstrap/$BOOTSTRAP_NAME.tar.gz.hash \
                    $(dirname $BOOTSTRAP_PATH)/$BOOTSTRAP_NAME.tar.gz.hash
            fi
        fi
    fi
fi

cd $BT_PRODUCTS/$appname
if [[ -n "$use_existing" ]]; then
    ISO=build/product.iso
    [[ -f "$ISO" ]] || fatal "iso $PWD/$ISO not found"
else
    info "Preperation done. Building appliance $appname."
    cd $BT_PRODUCTS/$appname
    deck -D build/root.sandbox || true
    make clean || true
    mkdir -p build
    make 2>&1 | tee build/log || true

    if [[ ! -e build/product.iso ]]; then
        if [[ -z "$BT_DEBUG" ]]; then
            deck -D build/root.sandbox >/dev/null 2>&1 || true
            make clean >/dev/null 2>&1 || true
        fi
        fatal "Build failed..."
    fi
fi

if [[ -z "$no_screens" ]]; then
    if [[ -n "$use_existing" ]]; then
        info "Product iso being loaded as docker container"
        # TODO make dockerize output more quiet when --quiet used - workaround via tail
        image_name=$(dockerize --quiet --iso build/product.iso --name $appname | tail -1)
    else
        info "Product rootfs being loaded as docker container"
        # TODO make dockerize output more quiet when --quiet used - workaround via tail
        image_name=$(dockerize --quiet --rootfs build/root.sandbox --deck | tail -1)
    fi
    
    info "Creating new product docker container from image and starting"
    app_cont_id=$(podman run -dt --tmpfs /tmp --tmpfs /run --tmpfs /run/lock $image_name)
    app_ip=$(podman inspect $app_cont_id --format "{{.NetworkSettings.IPAddress}}")

    export TKL_SCREENSHOT_PATH=$BT_PRODUCTS/$appname/build/screens
    mkdir -p $TKL_SCREENSHOT_PATH
    SELENIUM_CONT=docker.io/selenium/standalone-chrome
    SELENIUM_TAG=4.7.2-20221219

    info "Starting selenium container"
    INIT_CONF=/turnkey/public/tkldev-docker/inithooks.conf
    unset add_hosts
    if [[ -f "$INIT_CONF" ]]; then
        info "Loading default conf and adding fqdn to selenium hosts file"
        source $INIT_CONF
        [[ -n "$APP_DOMAIN" ]] || fatal "APP_DOMAIN not set, please check $INIT_CONF"
        add_hosts="--add-host=${APP_DOMAIN}:${app_ip}"
    else
        warning "$INIT_CONF not found - continuing with password defaults - may fail"
    fi

    # check if selenium container already exists
    existing_instance=$(podman ps -a --format "{{.ID}}:{{.Image}}" \
                | grep "$SELENIUM_CONT:$SELENIUM_TAG" || [[ $? == 1 ]])
    existing_id=$(sed -En "s|(^[a-f0-9]+):.*|\1|p" <<<"$existing_instance")
    if [[ -n "$existing_id" ]]; then
        info "existing selenium container found - cleaning"
        podman container stop $existing_id >/dev/null 2>&1 || [[ $? -eq 1 ]]
        podman container rm $existing_id >/dev/null 2>&1 || [[ $? -eq 1 ]]
    fi
    info "starting new selenium webdriver container (may require download)"
    sel_cont_id=$(podman run -d -p 4444:4444 -p 7900:7900 $add_hosts \
                        --shm-size="2g" $SELENIUM_CONT:$SELENIUM_TAG)

    # wait until container status is 'running'
    while [[ $(container_status $sel_cont_id) != "running" ]]; do
        sleep 1
    done
    info "container running - waiting for connection"
    for ping in {1..20}; do
        if ! curl localhost:7900 >/dev/null 2>&1; then
           sleep 1
        fi
        if [[ "$appname" != 'tkldev' ]]; then
            if ! curl --insecure https://$app_ip:12321 >/dev/null 2>&1; then
                sleep 1
            fi
        else
            # TODO need to handle tkldev here; just sleeping for now...
            sleep 1
        fi
    done

    tkl-docker-wait-ready "$app_cont_id"

    # set schema - most should be https, but there is at least one exception
    case $appname in
        gitlab)
            schema=http;;
        *)
            schema=https;;
    esac

    info "taking screenshots"
    count=0
    max_tries=60
    while [[ "$count" -lt $max_tries ]]; do
        count=$((count + 1))
        exit_code=0
        info "attempt $count"
        # note TKL_SCREENSHOT_PATH exported above
        clicksnap test $appname ${schema}://${APP_DOMAIN}/ || exit_code=$?
        if [[ $exit_code -eq 0 ]]; then
            info "Success"
            break
        else
            info "Clicksnap failed - guessing container not yet ready - waiting"
            sleep 2
        fi
    done
    [[ $exit_code -eq 0 ]] || fatal "Screenshots failed after $max_tries attempts"
fi

mkdir -p $BT_ISOS
unset arg
[[ -z "$no_screens" ]] || arg="--no-screens"
$BT/bin/iso-release --force $arg $BT_ISOS

if [[ "$publish" == "yes" ]]; then
    name=$(cat build/root.sandbox/etc/turnkey_version)
    $BT/bin/iso-publish $arg $BT_ISOS/$name.iso
fi

if [[ -z "$BT_DEBUG" ]]; then
    deck -D build/root.sandbox
    make clean
    if [[ -z "$no_screens" ]]; then
        info "stopping $appname container: $(podman stop $app_cont_id)"
        info "removing $appname container: $(podman rm $app_cont_id)"
        info "removing $appname image: $(podman rmi $image_name)"
    fi
fi
